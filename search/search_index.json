{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Polymer It's a library for creating server side content, that work for player's without mods or (required) resource packs! You can create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones (unlike bukkit/spigot ones, that are stored as vanilla block). This library also should work correctly with other, non-polymer mods and PolyMC! Adding as dependency: Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"eu.pb4:polymer:[TAG]\") } For [TAG] /polymer version I recommend you checking this maven . Before starting There are few things you need to keep in mind while using Polymer. All your code that interacts with Polymer should: Be thread safe - code can run on main server thread, player's connection thread or client side rendering thread. Make sure to check every time you cast if it's really instance of it. Sometimes World won't be ServerWorld . Never implement Polymer interfaces on Vanilla Items/Blocks with mixins, it will end up really, really badly. Never add new BlockStates to non-polymer blocks, as it will cause desyncs (see previous point)! Please don't even try using registry replacement, it will break many other mods. Getting started Items Blocks Entities Resource Packs Other useful tools/projects compatible with Polymer Server Translation API","title":"About Polymer"},{"location":"#about-polymer","text":"It's a library for creating server side content, that work for player's without mods or (required) resource packs! You can create blocks, items and entities, that not only will work fully on server side (and singleplayer), but also are represented on server the same as normal (vanilla/modded) ones (unlike bukkit/spigot ones, that are stored as vanilla block). This library also should work correctly with other, non-polymer mods and PolyMC!","title":"About Polymer"},{"location":"#adding-as-dependency","text":"Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"eu.pb4:polymer:[TAG]\") } For [TAG] /polymer version I recommend you checking this maven .","title":"Adding as dependency:"},{"location":"#before-starting","text":"There are few things you need to keep in mind while using Polymer. All your code that interacts with Polymer should: Be thread safe - code can run on main server thread, player's connection thread or client side rendering thread. Make sure to check every time you cast if it's really instance of it. Sometimes World won't be ServerWorld . Never implement Polymer interfaces on Vanilla Items/Blocks with mixins, it will end up really, really badly. Never add new BlockStates to non-polymer blocks, as it will cause desyncs (see previous point)! Please don't even try using registry replacement, it will break many other mods.","title":"Before starting"},{"location":"#getting-started","text":"Items Blocks Entities Resource Packs Other useful tools/projects compatible with Polymer Server Translation API","title":"Getting started"},{"location":"other/server-translation-api/","text":"Server Translation API It's a library for handling translations server side. It supports per player language, by using one provided by client on join/language change. Adding as dependency: Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"fr.catcore:server-translations-api:[TAG]\") } For [TAG] /translations api version I recommend you checking this maven . Usage To use i, you just need to use vanilla TranslationText with key specified by you in your code. Then you just need to create data/modid/lang folder in your mod resources. Then you can create there en_us.json for default translation and other language files for other. Example valid language file looks like this: { \"block.honeytech.pipe\": \"Pipe\", \"block.honeytech.item_extractor\": \"Item Extractor\", \"block.honeytech.trashcan\": \"Trash Can\", \"block.honeytech.cable\": \"Cable\", \"item.honeytech.diamond_dust\": \"Diamond Dust\", \"item.honeytech.raw_aluminium\": \"Raw Aluminium Ore\", \"item.honeytech.aluminium_ingot\": \"Aluminium Ingot\", \"item.honeytech.copper_wire\": \"Copper Wire\", \"item.honeytech.motor\": \"Motor\", \"gui.honeytech.show_recipes\": \"Show Recipes\" }","title":"Server Translation API"},{"location":"other/server-translation-api/#server-translation-api","text":"It's a library for handling translations server side. It supports per player language, by using one provided by client on join/language change.","title":"Server Translation API"},{"location":"other/server-translation-api/#adding-as-dependency","text":"Add it to your dependencies like this: repositories { maven { url 'https://maven.nucleoid.xyz' } } dependencies { modImplementation include(\"fr.catcore:server-translations-api:[TAG]\") } For [TAG] /translations api version I recommend you checking this maven .","title":"Adding as dependency:"},{"location":"other/server-translation-api/#usage","text":"To use i, you just need to use vanilla TranslationText with key specified by you in your code. Then you just need to create data/modid/lang folder in your mod resources. Then you can create there en_us.json for default translation and other language files for other. Example valid language file looks like this: { \"block.honeytech.pipe\": \"Pipe\", \"block.honeytech.item_extractor\": \"Item Extractor\", \"block.honeytech.trashcan\": \"Trash Can\", \"block.honeytech.cable\": \"Cable\", \"item.honeytech.diamond_dust\": \"Diamond Dust\", \"item.honeytech.raw_aluminium\": \"Raw Aluminium Ore\", \"item.honeytech.aluminium_ingot\": \"Aluminium Ingot\", \"item.honeytech.copper_wire\": \"Copper Wire\", \"item.honeytech.motor\": \"Motor\", \"gui.honeytech.show_recipes\": \"Show Recipes\" }","title":"Usage"},{"location":"polymer/blocks/","text":"Blocks Note These docs will only take care about polymer-related part of creation of blocks. You might want to see official Fabric Wiki for more in depth look into how to create blocks. You can skip some client side specific things, as it won't take effect server side (for example models and textures). Creation of blocks Creation of blocks, similarly to items, is mostly the same as vanilla. Only real difference is that your blocks need to implement Polymer's VirtualBlock interface. It exposes few defaulted methods for manipulation of client side visuals. Default implementation For most basic uses, there are default implementation of VirtualBlock : VirtualHeadBlock - It's an interface (!), that has basic implementation of player head based blocks, you still need to apply it to your Block class, BasicVirtualBlock - Same as vanilla Block . Selecting base visual block type. To change base block, you need to override 1 required method. There is also additional, optional one with more context, which you can also use. * Block getVirtualBlock() - It works for everything by default, mostly when more context isn't available, * Block getVirtualBlock(BlockPos pos, World world) - Used in cases where position context is available. It's only used in packets that don't contain BlockStates. By default, it redirects to getVirtualBlock() Both of these methods can't return null. They can also point to other VirtualBlock instances, but keep in mind to make validation if it's configurable by user! Example use: Making block look like a diamond @Override public Block getVirtualBlock() { return Blocks.DIAMOND_BLOCK; } Changing client-side and collision BlockStates If you want to change what BlockState will be used for server side collision and client side you need to override BlockState getVirtualBlockState(BlockState state) method. You can return other BlockState of VirtualBlock, but keep in mind you can only nest them up to 32! Example use: Changing BlockState to furnace with the same facing, but inverted \"lit\" BlockState property @Override public BlockState getVirtualBlockState(BlockState state) { return Blocks.FURNACE.getDefaultState() .with(AbstractFurnaceBlock.FACING, state.get(AbstractFurnaceBlock.FACING)) .with(AbstractFurnaceBlock.LIT, !state.get(AbstractFurnaceBlock.LIT)); } Sending additional data (signs/heads or even custom) In case if you want to send additional (to more customize look on client for signs/heads or additional data for companion mod), you need to override sendPacketsAfterCreation(ServerPlayerEntity player, BlockPos pos, BlockState blockState) . Technically you can do anything there, but ideally it should be only used for packets. Example use: Sending data required to render player head with skin @Override public void sendPacketsAfterCreation(ServerPlayerEntity player, BlockPos pos, BlockState blockState) { NbtCompound main = new NbtCompound(); NbtCompound skullOwner = SomeHelper.getSkullOwnerFor(this); main.putString(\"id\", \"minecraft:skull\"); main.put(\"SkullOwner\", skullOwner); main.putInt(\"x\", pos.getX()); main.putInt(\"y\", pos.getY()); main.putInt(\"z\", pos.getZ()); player.networkHandler.sendPacket(new BlockEntityUpdateS2CPacket(pos, 4, main)); } Using VirtualHeadBlock VirtualHeadBlock is an interface extending VirtualBlock with methods prepared for usage of player heads as a block. To modify texture, you just need to override String getVirtualHeadSkin(BlockState state) which should return texture value. To generate it you can use websites like ttps://mineskin.org/. Additionally, you can override BlockState getVirtualBlockState(BlockState state) to change rotation of Player Head Block. Example use: Setting skin value for VirtualHeadBlock @Override public BlockState getVirtualBlockState(BlockState state) { return \"ewogICJ0aW1lc3RhbXAiIDogMTYxNzk3NjcxOTAzNSwKICAicHJvZmlsZUlkIiA6ICJlZDUzZGQ4MTRmOWQ0YTNjYjRlYjY1MWRjYmE3N2U2NiIsCiAgInByb2ZpbGVOYW1lIiA6ICI0MTQxNDE0MWgiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTczNTE0YTIzMjQ1ZjE1ZGJhZDVmYjRlNjIyMTYzMDIwODY0Y2NlNGMxNWQ1NmRlM2FkYjkwZmE1YTcxMzdmZCIKICAgIH0KICB9Cn0\"; } Using BlockEntities The only thing you need to do to remove BlockEntity from being sent to client is registering its BlockEntityType with BlockHelper.registerVirtualBlockEntity(BlockEntityType types) . Limitations While it's supported, please limit creation of VirtualBlock light sources. Because of how Minecraft handles light updates on server/client, these can be little laggy (as it needs to be sent updates every time light changes) and not perfect, as client is emulating light by itself. Similarly, client recalculates some BlockStates, which can cause some desyncs.","title":"Blocks"},{"location":"polymer/blocks/#blocks","text":"Note These docs will only take care about polymer-related part of creation of blocks. You might want to see official Fabric Wiki for more in depth look into how to create blocks. You can skip some client side specific things, as it won't take effect server side (for example models and textures).","title":"Blocks"},{"location":"polymer/blocks/#creation-of-blocks","text":"Creation of blocks, similarly to items, is mostly the same as vanilla. Only real difference is that your blocks need to implement Polymer's VirtualBlock interface. It exposes few defaulted methods for manipulation of client side visuals.","title":"Creation of blocks"},{"location":"polymer/blocks/#default-implementation","text":"For most basic uses, there are default implementation of VirtualBlock : VirtualHeadBlock - It's an interface (!), that has basic implementation of player head based blocks, you still need to apply it to your Block class, BasicVirtualBlock - Same as vanilla Block .","title":"Default implementation"},{"location":"polymer/blocks/#selecting-base-visual-block-type","text":"To change base block, you need to override 1 required method. There is also additional, optional one with more context, which you can also use. * Block getVirtualBlock() - It works for everything by default, mostly when more context isn't available, * Block getVirtualBlock(BlockPos pos, World world) - Used in cases where position context is available. It's only used in packets that don't contain BlockStates. By default, it redirects to getVirtualBlock() Both of these methods can't return null. They can also point to other VirtualBlock instances, but keep in mind to make validation if it's configurable by user! Example use: Making block look like a diamond @Override public Block getVirtualBlock() { return Blocks.DIAMOND_BLOCK; }","title":"Selecting base visual block type."},{"location":"polymer/blocks/#changing-client-side-and-collision-blockstates","text":"If you want to change what BlockState will be used for server side collision and client side you need to override BlockState getVirtualBlockState(BlockState state) method. You can return other BlockState of VirtualBlock, but keep in mind you can only nest them up to 32! Example use: Changing BlockState to furnace with the same facing, but inverted \"lit\" BlockState property @Override public BlockState getVirtualBlockState(BlockState state) { return Blocks.FURNACE.getDefaultState() .with(AbstractFurnaceBlock.FACING, state.get(AbstractFurnaceBlock.FACING)) .with(AbstractFurnaceBlock.LIT, !state.get(AbstractFurnaceBlock.LIT)); }","title":"Changing client-side and collision BlockStates"},{"location":"polymer/blocks/#sending-additional-data-signsheads-or-even-custom","text":"In case if you want to send additional (to more customize look on client for signs/heads or additional data for companion mod), you need to override sendPacketsAfterCreation(ServerPlayerEntity player, BlockPos pos, BlockState blockState) . Technically you can do anything there, but ideally it should be only used for packets. Example use: Sending data required to render player head with skin @Override public void sendPacketsAfterCreation(ServerPlayerEntity player, BlockPos pos, BlockState blockState) { NbtCompound main = new NbtCompound(); NbtCompound skullOwner = SomeHelper.getSkullOwnerFor(this); main.putString(\"id\", \"minecraft:skull\"); main.put(\"SkullOwner\", skullOwner); main.putInt(\"x\", pos.getX()); main.putInt(\"y\", pos.getY()); main.putInt(\"z\", pos.getZ()); player.networkHandler.sendPacket(new BlockEntityUpdateS2CPacket(pos, 4, main)); }","title":"Sending additional data (signs/heads or even custom)"},{"location":"polymer/blocks/#using-virtualheadblock","text":"VirtualHeadBlock is an interface extending VirtualBlock with methods prepared for usage of player heads as a block. To modify texture, you just need to override String getVirtualHeadSkin(BlockState state) which should return texture value. To generate it you can use websites like ttps://mineskin.org/. Additionally, you can override BlockState getVirtualBlockState(BlockState state) to change rotation of Player Head Block. Example use: Setting skin value for VirtualHeadBlock @Override public BlockState getVirtualBlockState(BlockState state) { return \"ewogICJ0aW1lc3RhbXAiIDogMTYxNzk3NjcxOTAzNSwKICAicHJvZmlsZUlkIiA6ICJlZDUzZGQ4MTRmOWQ0YTNjYjRlYjY1MWRjYmE3N2U2NiIsCiAgInByb2ZpbGVOYW1lIiA6ICI0MTQxNDE0MWgiLAogICJzaWduYXR1cmVSZXF1aXJlZCIgOiB0cnVlLAogICJ0ZXh0dXJlcyIgOiB7CiAgICAiU0tJTiIgOiB7CiAgICAgICJ1cmwiIDogImh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvNTczNTE0YTIzMjQ1ZjE1ZGJhZDVmYjRlNjIyMTYzMDIwODY0Y2NlNGMxNWQ1NmRlM2FkYjkwZmE1YTcxMzdmZCIKICAgIH0KICB9Cn0\"; }","title":"Using VirtualHeadBlock"},{"location":"polymer/blocks/#using-blockentities","text":"The only thing you need to do to remove BlockEntity from being sent to client is registering its BlockEntityType with BlockHelper.registerVirtualBlockEntity(BlockEntityType types) .","title":"Using BlockEntities"},{"location":"polymer/blocks/#limitations","text":"While it's supported, please limit creation of VirtualBlock light sources. Because of how Minecraft handles light updates on server/client, these can be little laggy (as it needs to be sent updates every time light changes) and not perfect, as client is emulating light by itself. Similarly, client recalculates some BlockStates, which can cause some desyncs.","title":"Limitations"},{"location":"polymer/entities/","text":"Entities Note These docs will only take care about polymer-related part of creation of entities. You might want to see official Fabric Wiki for more in depth look into how to create entities. You can skip most client side specific things, as it won't take effect server side (for example rendering/models) Creation of entities Creation of entities is mostly the same as vanilla. You just need to implement VirtualEntity interface on your entity's class. It exposes few defaulted methods for manipulation of client side visuals. You also need to register your entity type as virtual, by using EntityHelper.registerVirtualEntityType(EntityType... types) . Changing client side entity. To select visual entity type, you just need to override EntityType<?> getVirtualEntityType() This method can't return null or another EntityType that points to other virtual entity, as it won't work. Example use: Displaying entity as zombie @Override public EntityType<?> getVirtualEntityType() { return EntityType.ZOMBIE; } Modifying held items You most likely want to modify items held by entity, to indicate its type. To do it you need to override List<Pair<EquipmentSlot, ItemStack>> getVirtualEntityEquipment(Map<EquipmentSlot, ItemStack> map) . Example use: Displaying real items with helmet replacement. @Override public List<Pair<EquipmentSlot, ItemStack>> getVirtualEntityEquipment(Map<EquipmentSlot, ItemStack> map) { List<Pair<EquipmentSlot, ItemStack>> list = new ArrayList<>(map.size()); for (Map.Entry<EquipmentSlot, ItemStack> entry : map.entrySet()) { if (entry.getKey() == EquipmentSlot.HEAD) { continue; } else { list.add(Pair.of(entry.getKey(), entry.getValue())); } } list.add(new Pair<>(EquipmentSlot.HEAD, new ItemStack(Items.WITHER_SKELETON_SKULL))); return list; } Modifying client-side data trackers For more control over entity, you can modify DataTracker values send to client directly. To do it, you need to override void modifyTrackedData(List<DataTracker.Entry<?>> data) method. data already doesn't contain any invalid data. You should also be safe around it, as sending DataTracker.Entry's, that don't exist on client-side entity representation will cause issues and errors! To get TrackedData , which is needed to create Entries, you will need to make accessors to get private static values from entity classes. Example use: Adding villager data to change how villager looks @Override public void modifyTrackedData(List<DataTracker.Entry<?>> data) { data.add(new DataTracker.Entry<>(VillagerEntityAccessor.getVillagerData(), new VillagerData(VillagerType.JUNGLE, VillagerProfession.FARMER, 3);)); }","title":"Entities"},{"location":"polymer/entities/#entities","text":"Note These docs will only take care about polymer-related part of creation of entities. You might want to see official Fabric Wiki for more in depth look into how to create entities. You can skip most client side specific things, as it won't take effect server side (for example rendering/models)","title":"Entities"},{"location":"polymer/entities/#creation-of-entities","text":"Creation of entities is mostly the same as vanilla. You just need to implement VirtualEntity interface on your entity's class. It exposes few defaulted methods for manipulation of client side visuals. You also need to register your entity type as virtual, by using EntityHelper.registerVirtualEntityType(EntityType... types) .","title":"Creation of entities"},{"location":"polymer/entities/#changing-client-side-entity","text":"To select visual entity type, you just need to override EntityType<?> getVirtualEntityType() This method can't return null or another EntityType that points to other virtual entity, as it won't work. Example use: Displaying entity as zombie @Override public EntityType<?> getVirtualEntityType() { return EntityType.ZOMBIE; }","title":"Changing client side entity."},{"location":"polymer/entities/#modifying-held-items","text":"You most likely want to modify items held by entity, to indicate its type. To do it you need to override List<Pair<EquipmentSlot, ItemStack>> getVirtualEntityEquipment(Map<EquipmentSlot, ItemStack> map) . Example use: Displaying real items with helmet replacement. @Override public List<Pair<EquipmentSlot, ItemStack>> getVirtualEntityEquipment(Map<EquipmentSlot, ItemStack> map) { List<Pair<EquipmentSlot, ItemStack>> list = new ArrayList<>(map.size()); for (Map.Entry<EquipmentSlot, ItemStack> entry : map.entrySet()) { if (entry.getKey() == EquipmentSlot.HEAD) { continue; } else { list.add(Pair.of(entry.getKey(), entry.getValue())); } } list.add(new Pair<>(EquipmentSlot.HEAD, new ItemStack(Items.WITHER_SKELETON_SKULL))); return list; }","title":"Modifying held items"},{"location":"polymer/entities/#modifying-client-side-data-trackers","text":"For more control over entity, you can modify DataTracker values send to client directly. To do it, you need to override void modifyTrackedData(List<DataTracker.Entry<?>> data) method. data already doesn't contain any invalid data. You should also be safe around it, as sending DataTracker.Entry's, that don't exist on client-side entity representation will cause issues and errors! To get TrackedData , which is needed to create Entries, you will need to make accessors to get private static values from entity classes. Example use: Adding villager data to change how villager looks @Override public void modifyTrackedData(List<DataTracker.Entry<?>> data) { data.add(new DataTracker.Entry<>(VillagerEntityAccessor.getVillagerData(), new VillagerData(VillagerType.JUNGLE, VillagerProfession.FARMER, 3);)); }","title":"Modifying client-side data trackers"},{"location":"polymer/items/","text":"Items Note These docs will only take care about polymer-related part of creation of items. You might want to see official Fabric Wiki for more in depth look into how to create items. You can skip some client side specific things, as it won't take effect server side (excluding item groups, as they can be used by other mods) Creation of items Creation of items is mostly the same as vanilla. Only real difference is that your items need to implement Polymer's VirtualItem interface. It exposes few defaulted methods for manipulation of client side visuals. Default implementation For most basic uses, there are default implementation of VirtualItem : BasicVirtualItem - Same as vanilla Item , VirtualBlockItem - Same as vanilla BlockItem , VirtualHeadBlockItem - Similar to VirtualBlockItem , but for Blocks implementing VirtualHeadBlock interface. Selecting visual item type. To select visual item type, there are 1 required and 1 optional methods you need to override: Item getVirtualItem() - It works for everything by default, mostly in cases where ItemStack isn't available, Item getVirtualItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) - Used in most cases, it includes reference to ItemStack and Player, by default it redirects to getVirtualItem() Both of these methods can't return null. They can also point to other VirtualItem instance, but keep in mind to make validation if it's configurable by user! Example use: Changing client-side item to diamond @Override public Item getVirtualItem() { return Items.DIAMOND; } Changing client-side item to diamond blocks if there is more than 32 in ItemStack, otherwise to diamonds @Override public Item getVirtualItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) { return itemStack.getCount() > 32 ? Items.DIAMOND_BLOCK : Items.DIAMOND; } Manipulation of client side ItemStack Sometimes it's useful to manipulate entire ItemStack, as it allows achieving better effects. To do so, you need to override the ItemStack getVirtualItemStack(ItemStack itemStack, @Nullable ServerPlayerEntity player) method. However, keep in mind that making nbt incorrect might create some issues (for example breaking items in creative mode)! Ideally you should modify output of VirtualItem.super.getVirtualItemStack(itemStack, player) , ItemHelper.createBasicVirtualItemStack(itemStack, player) or ItemHelper.createMinimalVirtualItemStack(itemStack, player) , as they contain all required NBT. Example use: Adding enchanting glint to item. @Override public ItemStack getVirtualItemStack(ItemStack itemStack, ServerPlayerEntity player) { ItemStack out = VirtualItem.super.getVirtualItemStack(itemStack, player); out.addEnchantment(Enchantments.LURE, 0); return out; } Support of models/CustomModelData You can change custom model data of virtual model by simple overriding int getCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) . You can return -1 to disable it, or any number above it to set value of it. Ideally you should return value created with polymer's resource pack utils , but nothing blocks you from using any other ones. Example usage: Changing client-side item CustomModelData to previously stored value. @Override public int getCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) { // Instance of CMDInfo, see info above return this.cmd.value(); } Manipulation of non-virtual items Sometimes, you might want to manipulate other vanilla/modded items without implementing VirtualItem on them. You can do it by using few events from ItemHelper . Forcing items to go through Polymer To force items to go through polymer's client side item creation, you need to register event handler for ItemHelper.VIRTUAL_ITEM_CHECK event. You can register it by using ItemHelper.VIRTUAL_ITEM_CHECK.register(ItemStack -> boolean) lambda. Example use: Making every item with string NBT tag of \"Test\" go through polymer ItemHelper.VIRTUAL_ITEM_CHECK.register( (itemStack) -> { return itemStack.hasNbt() && itemStack.getNbt().contains(\"Test\", NbtElement.STRING_TYPE); } ); Modification of Virtual/Client side item After getting vanilla (or for any VirtualItem by default) you can modify any client side item with ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT event. Just keep in mind doing it incorrectly can cause issues (mostly around creative mode, but also in case you modify original item). You change the client side item by either directly modifying virtual ItemStack or creating new one and returning it. Ideally you should also keep previous nbt, just so it can work nicely, You can register this event by using ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT.register(((ItemStack original, ItemStack virtual, ServerPlayerEntity player) -> ItemStack) lambda. Example use: Hiding enchantment glint for items with HideEnchantments: 1b nbt tag ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().getBoolean(\"HideEnchantments\")) { virtual.getNbt().remove(\"Enchantments\"); } return virtual; } ); Replacing look/name of ItemStack with \"Test\" NBT tag ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().contains(\"Test\", NbtElement.STRING_TYPE)) { ItemStack out = new ItemStack(Items.DIAMOND_SWORD, virtual.getCount()); out.setNbt(virtual.getNbt()); out.setCustomName(new LiteralText(\"TEST VALUE: \" + original.getNbt().getString(\"Test\")).formatted(Formatting.WHITE)); return out; } return virtual; } ); Making items mining calculated on server side You can also force item's mining speed to be calculated server side (which happens by default to every VirtualItem). Only thing you need to do is just listening to BlockHelper.SERVER_SIDE_MINING_CHECK event. Example use: BlockHelper.SERVER_SIDE_MINING_CHECK.register( (player, pos, blockState) -> { var itemStack = player.getMainHandStack(); return EnchantmentHelper.getLevel(MyEnchanments.SLOW_MINING, itemStack) > 0; } ); Enchantments The only thing to make your enchantment fully server side is implementation of VirtualObject interface. You also might want to manipulate some things from Polymer Block/ItemHelper events.","title":"Items"},{"location":"polymer/items/#items","text":"Note These docs will only take care about polymer-related part of creation of items. You might want to see official Fabric Wiki for more in depth look into how to create items. You can skip some client side specific things, as it won't take effect server side (excluding item groups, as they can be used by other mods)","title":"Items"},{"location":"polymer/items/#creation-of-items","text":"Creation of items is mostly the same as vanilla. Only real difference is that your items need to implement Polymer's VirtualItem interface. It exposes few defaulted methods for manipulation of client side visuals.","title":"Creation of items"},{"location":"polymer/items/#default-implementation","text":"For most basic uses, there are default implementation of VirtualItem : BasicVirtualItem - Same as vanilla Item , VirtualBlockItem - Same as vanilla BlockItem , VirtualHeadBlockItem - Similar to VirtualBlockItem , but for Blocks implementing VirtualHeadBlock interface.","title":"Default implementation"},{"location":"polymer/items/#selecting-visual-item-type","text":"To select visual item type, there are 1 required and 1 optional methods you need to override: Item getVirtualItem() - It works for everything by default, mostly in cases where ItemStack isn't available, Item getVirtualItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) - Used in most cases, it includes reference to ItemStack and Player, by default it redirects to getVirtualItem() Both of these methods can't return null. They can also point to other VirtualItem instance, but keep in mind to make validation if it's configurable by user! Example use: Changing client-side item to diamond @Override public Item getVirtualItem() { return Items.DIAMOND; } Changing client-side item to diamond blocks if there is more than 32 in ItemStack, otherwise to diamonds @Override public Item getVirtualItem(ItemStack itemStack, @Nullable ServerPlayerEntity player) { return itemStack.getCount() > 32 ? Items.DIAMOND_BLOCK : Items.DIAMOND; }","title":"Selecting visual item type."},{"location":"polymer/items/#manipulation-of-client-side-itemstack","text":"Sometimes it's useful to manipulate entire ItemStack, as it allows achieving better effects. To do so, you need to override the ItemStack getVirtualItemStack(ItemStack itemStack, @Nullable ServerPlayerEntity player) method. However, keep in mind that making nbt incorrect might create some issues (for example breaking items in creative mode)! Ideally you should modify output of VirtualItem.super.getVirtualItemStack(itemStack, player) , ItemHelper.createBasicVirtualItemStack(itemStack, player) or ItemHelper.createMinimalVirtualItemStack(itemStack, player) , as they contain all required NBT. Example use: Adding enchanting glint to item. @Override public ItemStack getVirtualItemStack(ItemStack itemStack, ServerPlayerEntity player) { ItemStack out = VirtualItem.super.getVirtualItemStack(itemStack, player); out.addEnchantment(Enchantments.LURE, 0); return out; }","title":"Manipulation of client side ItemStack"},{"location":"polymer/items/#support-of-modelscustommodeldata","text":"You can change custom model data of virtual model by simple overriding int getCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) . You can return -1 to disable it, or any number above it to set value of it. Ideally you should return value created with polymer's resource pack utils , but nothing blocks you from using any other ones. Example usage: Changing client-side item CustomModelData to previously stored value. @Override public int getCustomModelData(ItemStack itemStack, @Nullable ServerPlayerEntity player) { // Instance of CMDInfo, see info above return this.cmd.value(); }","title":"Support of models/CustomModelData"},{"location":"polymer/items/#manipulation-of-non-virtual-items","text":"Sometimes, you might want to manipulate other vanilla/modded items without implementing VirtualItem on them. You can do it by using few events from ItemHelper .","title":"Manipulation of non-virtual items"},{"location":"polymer/items/#forcing-items-to-go-through-polymer","text":"To force items to go through polymer's client side item creation, you need to register event handler for ItemHelper.VIRTUAL_ITEM_CHECK event. You can register it by using ItemHelper.VIRTUAL_ITEM_CHECK.register(ItemStack -> boolean) lambda. Example use: Making every item with string NBT tag of \"Test\" go through polymer ItemHelper.VIRTUAL_ITEM_CHECK.register( (itemStack) -> { return itemStack.hasNbt() && itemStack.getNbt().contains(\"Test\", NbtElement.STRING_TYPE); } );","title":"Forcing items to go through Polymer"},{"location":"polymer/items/#modification-of-virtualclient-side-item","text":"After getting vanilla (or for any VirtualItem by default) you can modify any client side item with ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT event. Just keep in mind doing it incorrectly can cause issues (mostly around creative mode, but also in case you modify original item). You change the client side item by either directly modifying virtual ItemStack or creating new one and returning it. Ideally you should also keep previous nbt, just so it can work nicely, You can register this event by using ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT.register(((ItemStack original, ItemStack virtual, ServerPlayerEntity player) -> ItemStack) lambda. Example use: Hiding enchantment glint for items with HideEnchantments: 1b nbt tag ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().getBoolean(\"HideEnchantments\")) { virtual.getNbt().remove(\"Enchantments\"); } return virtual; } ); Replacing look/name of ItemStack with \"Test\" NBT tag ItemHelper.VIRTUAL_ITEM_MODIFICATION_EVENT.register( (original, virtual, player) -> { if (original.hasNbt() && original.getNbt().contains(\"Test\", NbtElement.STRING_TYPE)) { ItemStack out = new ItemStack(Items.DIAMOND_SWORD, virtual.getCount()); out.setNbt(virtual.getNbt()); out.setCustomName(new LiteralText(\"TEST VALUE: \" + original.getNbt().getString(\"Test\")).formatted(Formatting.WHITE)); return out; } return virtual; } );","title":"Modification of Virtual/Client side item"},{"location":"polymer/items/#making-items-mining-calculated-on-server-side","text":"You can also force item's mining speed to be calculated server side (which happens by default to every VirtualItem). Only thing you need to do is just listening to BlockHelper.SERVER_SIDE_MINING_CHECK event. Example use: BlockHelper.SERVER_SIDE_MINING_CHECK.register( (player, pos, blockState) -> { var itemStack = player.getMainHandStack(); return EnchantmentHelper.getLevel(MyEnchanments.SLOW_MINING, itemStack) > 0; } );","title":"Making items mining calculated on server side"},{"location":"polymer/items/#enchantments","text":"The only thing to make your enchantment fully server side is implementation of VirtualObject interface. You also might want to manipulate some things from Polymer Block/ItemHelper events.","title":"Enchantments"},{"location":"polymer/resource-packs/","text":"Resource packs While Polymer wasn't designed around resource pack, it provides simple resource pack utilities to make it easier for mods to stay compatible with each other. Currently, it's limited only to item models, as Vanilla only allows these (as of 1.17.1 version). Registering assets This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization. Adding mod assets to resource pack First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean ResourcePackUtils.addModAsAssetsSource(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer. Requesting model for item After that you can register your models by calling CMDInfo ResourcePackUtils.requestCustomModelData(Item vanillaItem, Identifier modelPath) . It returns CMDInfo with contains all information you need for applying custom model data to your items. You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: CMDInfo cmdInfo = ResourcePackUtils.requestCustomModelData(Items.IRON_SWORD, new Identifier(\"mymod\", \"silver_sword\")); Checking players Checking if player has resource pack is quite simple. You just need to call boolean ResourcePackUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (ResourcePackUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); } Making pack required To make font required, you just need to call ResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible. Building resource pack To create resource pack you only need to execute /polymer generate command. Resource pack will be located in polymer-resourcepack/output folder.","title":"Resource packs"},{"location":"polymer/resource-packs/#resource-packs","text":"While Polymer wasn't designed around resource pack, it provides simple resource pack utilities to make it easier for mods to stay compatible with each other. Currently, it's limited only to item models, as Vanilla only allows these (as of 1.17.1 version).","title":"Resource packs"},{"location":"polymer/resource-packs/#registering-assets","text":"This is quite simple. You just need to do things written below. Ideally it all should run at your mod's initialization.","title":"Registering assets"},{"location":"polymer/resource-packs/#adding-mod-assets-to-resource-pack","text":"First step for adding assets to resource pack is marking mod as asset source. To do it you just need to call boolean ResourcePackUtils.addModAsAssetsSource(String modid) , which returns true if modid is valid. This should be called ideally in your mod initializer.","title":"Adding mod assets to resource pack"},{"location":"polymer/resource-packs/#requesting-model-for-item","text":"After that you can register your models by calling CMDInfo ResourcePackUtils.requestCustomModelData(Item vanillaItem, Identifier modelPath) . It returns CMDInfo with contains all information you need for applying custom model data to your items. You can execute this function before making your mod an asset source, but it should be run before resource pack is build. Example use: CMDInfo cmdInfo = ResourcePackUtils.requestCustomModelData(Items.IRON_SWORD, new Identifier(\"mymod\", \"silver_sword\"));","title":"Requesting model for item"},{"location":"polymer/resource-packs/#checking-players","text":"Checking if player has resource pack is quite simple. You just need to call boolean ResourcePackUtils.hasPack(ServerPlayerEntity player) . Example use: Identifier font; if (ResourcePackUtils.hasPack(player)) { font = new Identifier(\"mymod\", \"myfont\"); } else { font = new Identifier(\"minecraft\", \"default\"); }","title":"Checking players"},{"location":"polymer/resource-packs/#making-pack-required","text":"To make font required, you just need to call ResourcePackUtil.markAsRequired() . However, Polymer doesn't contain any utilities for sending packs, as it should be implemented by other mods (or use vanilla one). One exception is resource pack on client, which will get effected by that. I also recommend you to keep it optional if it's possible.","title":"Making pack required"},{"location":"polymer/resource-packs/#building-resource-pack","text":"To create resource pack you only need to execute /polymer generate command. Resource pack will be located in polymer-resourcepack/output folder.","title":"Building resource pack"}]}